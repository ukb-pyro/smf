<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Teleology → Recursion → Sonata</title>
<style>
  :root{ --bg:#111; --text:#eee; --muted:#bbb; --ink:#9ad1ff; }
  *{ box-sizing:border-box }
  html,body{ height:100% }
  body{
    margin:0; background:var(--bg); color:var(--text);
    font:16px/1.5 "Courier New", Courier, monospace;
    display:flex; flex-direction:column; align-items:center; justify-content:center;
    padding:1rem; gap:1rem;
  }
  h1{
    font-size:clamp(1rem,2.6vw,1.4rem); letter-spacing:.1em; margin:0; text-align:center; color:#ddd;
  }
  a{ color:#ddd; text-decoration:none; transition:color .25s ease }
  a:hover{ color:var(--ink); text-decoration:underline }
  canvas{ width:min(80vmin,900px); height:auto; aspect-ratio:4/1.6; display:block }
  footer{ color:#777; font-size:clamp(.7rem,1.5vw,.85rem) }
</style>
</head>
<body>
  <h1>
    <a href="https://claude.ai/public/artifacts/4ec0a53e-03b8-4462-ab92-ac9c9b65e162" target="_blank" rel="noopener">Teleology</a> →
    <a href="https://abikesa.github.io/buddhism/" target="_blank" rel="noopener">Recursion</a> →
    <a href="https://ukb-pyro.github.io/inf/" target="_blank" rel="noopener">Sonata</a> →
  </h1>

  <canvas id="stage" aria-label="Smooth morph: line → circle → infinity → line"></canvas>

  <footer>© 2025 Ukubona LLC</footer>

<script>
(function(){
  const canvas = document.getElementById('stage');
  const ctx = canvas.getContext('2d');

  // --- sizing with HiDPI crispness ---
  function fit(){
    const cssW = canvas.getBoundingClientRect().width;
    const cssH = cssW / (4/1.6);
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width  = Math.floor(cssW * dpr);
    canvas.height = Math.floor(cssH * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
  }

  // parametric shapes sampled at uniform t in [0,1)
  const N = 900; // many points for imperceptible transitions
  const T = 8_000; // ms per morph leg (long & smooth)
  const CYCLE = T * 3; // line->circle, circle->∞, ∞->line
  const TWO_PI = Math.PI * 2;

  // ease: very gentle S-curve (cosine)
  const ease = t => 0.5 - 0.5 * Math.cos(Math.PI * t);

  // base sampler returning arrays of [x,y]
  function sample(fn){
    const pts = new Array(N);
    for(let i=0;i<N;i++){
      const t = i / N;
      pts[i] = fn(t);
    }
    return pts;
  }

  // shapes centered at (0,0) with radius a, later scaled to canvas
  const line = sample(t => [ (t*2-1), 0 ]);                        // horizontal segment [-1,1]×{0}
  const circle = sample(t => [ Math.cos(TWO_PI*t), Math.sin(TWO_PI*t) ]); // unit circle
  // Lemniscate of Gerono (sideways ∞), vertically softened to better match circle
  const lemni = sample(t => {
    const th = TWO_PI * t;
    const x = Math.cos(th);
    const y = 0.60 * Math.sin(th) * Math.cos(th); // 0.5*sin(2θ) scaled
    return [x, y];
  });

  // interpolate between two shapes, pointwise
  function blend(a, b, m){
    const out = new Array(N);
    for(let i=0;i<N;i++){
      const x = a[i][0] + (b[i][0] - a[i][0]) * m;
      const y = a[i][1] + (b[i][1] - a[i][1]) * m;
      out[i] = [x, y];
    }
    return out;
  }

  // subtle "breathing" on radius to avoid mechanical feel
  function radius(now, base){
    return base * (1 + 0.02 * Math.sin(now/3000) + 0.01 * Math.cos(now/7000));
  }

  function draw(now){
    fit();
    const w = canvas.width / (window.devicePixelRatio||1);
    const h = canvas.height / (window.devicePixelRatio||1);
    const cx = w/2, cy = h/2;
    const scale = Math.min(w, h) * 0.38;

    // which leg of the cycle?
    const t = (now % CYCLE);
    const leg = Math.floor(t / T);          // 0,1,2
    const local = (t % T) / T;              // 0..1 within leg
    const m = ease(local);                  // eased morph amount

    // choose endpoints
    let A, B;
    if(leg === 0){ A = line;   B = circle; }
    else if(leg === 1){ A = circle; B = lemni; }
    else { A = lemni; B = line; }

    // blend and render
    const pts = blend(A, B, m);
    const r = radius(now, scale);

    ctx.clearRect(0,0,w,h);
    ctx.save();
    ctx.translate(cx, cy);

    ctx.beginPath();
    for(let i=0;i<N;i++){
      const x = pts[i][0] * r;
      const y = pts[i][1] * r;
      if(i===0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    // for circle/lemni, gently close; for the line it’s effectively a straight segment
    ctx.closePath();

    ctx.lineWidth = Math.max(2, Math.min(6, w*0.006));
    ctx.lineJoin = "round";
    ctx.lineCap  = "round";
    ctx.strokeStyle = "#9ad1ff";
    ctx.shadowColor = "rgba(154,209,255,.25)";
    ctx.shadowBlur = 8;
    ctx.stroke();

    ctx.restore();
    requestAnimationFrame(draw);
  }

  fit();
  requestAnimationFrame(draw);
  window.addEventListener('resize', fit, {passive:true});
})();
</script>
</body>
</html>
