<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Teleology → Recursion → Sonata</title>
<style>
  :root{ --bg:#111; --text:#eee; --ink:#9ad1ff }
  *{ box-sizing:border-box }
  html,body{ height:100% }
  body{
    margin:0; background:var(--bg); color:var(--text);
    font:16px/1.5 "Courier New", Courier, monospace;
    display:flex; flex-direction:column; align-items:center; justify-content:center;
    padding:1rem; gap:1rem;
  }
  h1{ font-size:clamp(1rem,2.6vw,1.4rem); letter-spacing:.1em; margin:0; text-align:center; color:#ddd }
  a{ color:#ddd; text-decoration:none } a:hover{ color:var(--ink); text-decoration:underline }
  canvas{ width:min(84vmin,980px); height:auto; aspect-ratio:4/1.6; display:block }
  footer{ color:#777; font-size:clamp(.7rem,1.5vw,.85rem) }
</style>
</head>
<body>
  <h1>
    <a href="https://claude.ai/public/artifacts/4ec0a53e-03b8-4462-ab92-ac9c9b65e162" target="_blank" rel="noopener">Teleology</a> →
    <a href="https://abikesa.github.io/buddhism/" target="_blank" rel="noopener">Recursion</a> →
    <a href="https://ukb-pyro.github.io/inf/" target="_blank" rel="noopener">Sonata</a> →
  </h1>

  <canvas id="stage" aria-label="Adagio sostenuto: line → circle → ∞ → broken ∞ → line"></canvas>

  <footer>© 2025 Ukubona LLC</footer>

<script>
(() => {
  const canvas = document.getElementById('stage');
  const ctx = canvas.getContext('2d');

  // HiDPI sizing
  function fit(){
    const cssW = canvas.getBoundingClientRect().width;
    const cssH = cssW / (4/1.6);
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width  = Math.floor(cssW * dpr);
    canvas.height = Math.floor(cssH * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  // --- tempo & resolution ---
  const N      = 1400;    // dense sampling for imperceptible morphs
  const LEG_MS = 45000;   // adagio sostenuto: 45s per leg
  const TWO_PI = Math.PI * 2;

  // ultra-gentle easing (cosine-in-out)
  const ease = t => 0.5 - 0.5 * Math.cos(Math.PI * t);

  // sample helper
  function sample(fn){
    const pts = new Array(N);
    for(let i=0;i<N;i++) pts[i] = fn(i/N);
    return pts;
  }

  // canonical shapes (centered at origin, radius≈1)
  const line   = sample(u => [ (u*2-1), 0 ]);
  const circle = sample(u => [ Math.cos(TWO_PI*u), Math.sin(TWO_PI*u) ]);
  const lemni  = sample(u => { // lemniscate of Gerono, softened vertically
    const th = TWO_PI*u;
    return [ Math.cos(th), 0.60*Math.sin(th)*Math.cos(th) ];
  });

  // index near lemniscate crossing (for the "break")
  const lemniCrossIdx = (() => {
    let k=0, best=1e9;
    for(let i=0;i<N;i++){
      const [x,y] = lemni[i];
      const r2 = x*x + y*y;
      if(r2 < best){ best=r2; k=i; }
    }
    return k;
  })();

  // pointwise blend
  function blend(A,B,m){
    const out = new Array(N);
    for(let i=0;i<N;i++){
      const a=A[i], b=B[i];
      out[i] = [ a[0] + (b[0]-a[0])*m, a[1] + (b[1]-a[1])*m ];
    }
    return out;
  }

  // subtle breathing on global radius so it never feels mechanical
  function radius(now, base){
    return base * (1 + 0.02*Math.sin(now/5200) + 0.01*Math.cos(now/8800));
  }

  // draw a (possibly open) curve; when gapFrac>0 omit an arc (two ends)
  function strokeCurve(pts, {closed=false, gapFrac=0, gapIndex=0, w}){
    ctx.beginPath();

    if(gapFrac > 0){
      const n    = pts.length;
      const gapN = Math.max(2, Math.floor(n*gapFrac));
      const s    = ((gapIndex % n) + n) % n;
      const cnt  = n - gapN;

      // draw cnt points as a single open strand
      for(let k=0;k<cnt;k++){
        const i = (s + k) % n;
        const p = pts[i];
        if(k===0) ctx.moveTo(p[0], p[1]); else ctx.lineTo(p[0], p[1]);
      }
    } else {
      // full curve
      ctx.moveTo(pts[0][0], pts[0][1]);
      for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0], pts[i][1]);
      if(closed) ctx.closePath();
    }

    ctx.lineWidth   = Math.max(2, Math.min(6, w*0.006));
    ctx.lineJoin    = "round";
    ctx.lineCap     = "round";
    ctx.strokeStyle = "#9ad1ff";
    ctx.shadowColor = "rgba(154,209,255,.18)";
    ctx.shadowBlur  = 6;
    ctx.stroke();
  }

  function frame(now){
    fit();

    const w  = canvas.width / (window.devicePixelRatio||1);
    const h  = canvas.height / (window.devicePixelRatio||1);
    const cx = w/2, cy = h/2;
    const base = Math.min(w, h) * 0.38;
    const r    = radius(now, base);

    // four-leg cycle
    const CYCLE = LEG_MS*4;
    const t     = (now % CYCLE);
    const leg   = Math.floor(t / LEG_MS);   // 0..3
    const local = (t % LEG_MS) / LEG_MS;    // 0..1
    const m     = ease(local);

    let A, B, closed=false, gapFrac=0, gapIndex=0;

    if(leg === 0){
      // line -> circle (two teloi remain visible; seal only at transition edge)
      A = line; B = circle;
      closed  = false;      // keep open; endpoints "kiss" at the very end
      gapFrac = 0;          // no artificial gap
    } else if(leg === 1){
      // circle -> lemni (fully closed; absolutely no gap)
      A = circle; B = lemni;
      closed  = true;
      gapFrac = 0;
    } else if(leg === 2){
      // lemni -> broken lemni (grow a gap at the crossing)
      A = lemni; B = lemni; // shape fixed; only gap changes
      closed  = false;
      gapFrac = 0.22 * m;   // up to ~22% arc removed
      gapIndex= lemniCrossIdx;
    } else {
      // broken lemni -> line (stay open; shrink gap smoothly while straightening)
      A = lemni; B = line;
      closed  = false;
      // carry the break at start, then fade it out as we approach the line
      gapFrac = 0.22 * (1 - m);
      gapIndex= lemniCrossIdx;
    }

    // blend & place
    const pts = blend(A, B, m);
    for(let i=0;i<N;i++){
      pts[i][0] = cx + pts[i][0]*r;
      pts[i][1] = cy + pts[i][1]*r;
    }

    ctx.clearRect(0,0,w,h);
    strokeCurve(pts, {closed, gapFrac, gapIndex, w});

    requestAnimationFrame(frame);
  }

  fit();
  requestAnimationFrame(frame);
  window.addEventListener('resize', fit, {passive:true});
})();
</script>
</body>
</html>
